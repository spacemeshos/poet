syntax = "proto3";

import "google/api/annotations.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";

package rpc.api.v1;

service PoetService {

    rpc PowParams(PowParamsRequest) returns (PowParamsResponse) {
        option (google.api.http) = {
            get: "/v1/pow_params"
        };
    }

    /**
    Submit registers data to the service's current open round,
    to be included its later generated proof.
    */
    rpc Submit (SubmitRequest) returns (SubmitResponse) {
        option (google.api.http) = {
            post: "/v1/submit",
            body: "*",
        };
    }

    /**
    Info returns general information concerning the service,
    including its identity pubkey.
    */
    rpc Info (InfoRequest) returns (InfoResponse) {
        option (google.api.http) = {
            get: "/v1/info"
        };
    }

    /**
    roof returns the generated proof for given round id.
    */
    rpc Proof(ProofRequest) returns (ProofResponse) {
        option (google.api.http) = {
            get: "/v1/proofs/{round_id}"
        };
    }
}

message PowParams {
    // Difficulty of the PoW challenge (in terms of leading zero bits in the hash)
    uint32 difficulty = 1;
    // The challenge to be used for the PoW
    bytes challenge = 2;
}

message PowParamsRequest {}
message PowParamsResponse {
    PowParams pow_params = 1;
}

message SubmitRequest {
    // Proof of Work nonce
    // deprecated - use certificate instead
    uint64 nonce = 1;
    // Proof of Work parameters that were used to generate the nonce
    // deprecated - use certificate instead
    PowParams pow_params = 2;
    // Prefix to be added to challenge for signature verification
    bytes prefix = 3;
    // The PoET challenge to be registered for the open round
    bytes challenge = 4;
    // The user's public key (node ID)
    bytes pubkey = 5;
    // The user's signature over the challenge
    bytes signature = 6;
    // The time by which the proof is needed.
    // If the currently open round will end after this time
    // and the  proof cannot be generated by this time, the request will be rejected.
    google.protobuf.Timestamp deadline = 7;

    message Certificate {
        bytes data = 1;
        // The certifier's signature over `data`
        // confirming that the pubkey is verified.
        bytes signature = 2;
    }
    Certificate certificate = 8;
}

message SubmitResponse {
    string round_id = 1;
    google.protobuf.Duration round_end = 3;
}

message InfoRequest {}

message InfoResponse {
    // formerly open_round_id and executing_round_id
    reserved 1, 2;
    bytes service_pubkey = 3;

    google.protobuf.Duration phase_shift = 4;
    google.protobuf.Duration cycle_gap = 5;

    message Cerifier {
        string url = 1;
        bytes pubkey = 2;
    }
    Cerifier certifier = 6;
}

message MembershipProof {
    int32 index = 1;
    bytes root = 2;
    repeated bytes proof = 3;
}

message MerkleProof {
    bytes root = 1;
    repeated bytes proven_leaves = 2;
    repeated bytes proof_nodes = 3;
}

message PoetProof {
    MerkleProof proof = 1;
    repeated bytes members = 2;
    uint64 leaves = 3;
}

message ProofRequest {
    string round_id = 1;
}

message ProofResponse {
    PoetProof proof = 1;
    bytes pubkey = 2;
}
