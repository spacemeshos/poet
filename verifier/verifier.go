package verifier

import (
	"bytes"
	"errors"
	"fmt"
	"slices"

	"github.com/spacemeshos/merkle-tree"
	"golang.org/x/exp/maps"

	"github.com/spacemeshos/poet/shared"
)

// Validate verifies that a Merkle proof was generated by an honest PoET prover. It validates that the number of proven
// leaves matches the security param, validates the Merkle proof itself and verifies the labels are derived from the
// left cousins in the Merkle tree.
func Validate(proof shared.MerkleProof, labelHashFunc func(data []byte) []byte,
	merkleHashFunc merkle.HashFunc, numLeaves uint64, securityParam uint8,
) error {
	if int(securityParam) != len(proof.ProvenLeaves) {
		return fmt.Errorf("number of proven leaves (%d) must be equal to security param (%d)",
			len(proof.ProvenLeaves), securityParam,
		)
	}

	provenLeafIndices := maps.Keys((shared.FiatShamir(proof.Root, numLeaves, securityParam)))
	slices.Sort(provenLeafIndices)

	valid, parkingSnapshots, err := merkle.ValidatePartialTreeWithParkingSnapshots(
		provenLeafIndices,
		proof.ProvenLeaves,
		proof.ProofNodes,
		proof.Root,
		merkleHashFunc,
	)
	if err != nil {
		return fmt.Errorf("error while validating merkle proof: %w", err)
	}
	if !valid {
		return errors.New("merkle proof not valid")
	}
	if len(parkingSnapshots) != len(proof.ProvenLeaves) {
		return fmt.Errorf(
			"merkle proof not valid: len(parkingSnapshots) != len(proof.ProvenLeaves) (%d != %d)",
			len(parkingSnapshots),
			len(proof.ProvenLeaves),
		)
	}

	makeLabel := shared.MakeLabelFunc()
	for id, label := range proof.ProvenLeaves {
		expectedLabel := makeLabel(labelHashFunc, provenLeafIndices[id], parkingSnapshots[id])
		if !bytes.Equal(expectedLabel, label) {
			return fmt.Errorf("label at index %d incorrect - expected: %x actual: %x", id, expectedLabel, label)
		}
	}

	return nil
}
